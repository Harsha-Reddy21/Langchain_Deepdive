{
  "documentation": [
    {
      "content": "Python Fundamentals and Best Practices:\n\nVariables and Data Types:\n- Use descriptive variable names (user_age instead of ua)\n- Python is dynamically typed but use type hints for clarity\n- Common data types: int, float, str, bool, list, tuple, dict, set\n- Use snake_case for variable and function names\n- Use UPPER_CASE for constants\n\nControl Structures:\n- Use if/elif/else for conditional logic\n- Use for and while loops appropriately\n- Use break and continue for loop control\n- Use range() for numeric loops\n\nFunctions:\n- Define functions with def keyword\n- Use docstrings for function documentation\n- Return values explicitly\n- Use default parameters when appropriate\n- Use *args and **kwargs for flexible arguments\n\nCollections:\n- Lists: Mutable, ordered sequences [1, 2, 3]\n- Tuples: Immutable, ordered sequences (1, 2, 3)\n- Dictionaries: Key-value pairs {\"key\": \"value\"}\n- Sets: Unordered, unique elements {1, 2, 3}\n\nList Comprehensions:\n- Use for simple transformations: [x*2 for x in numbers]\n- Include conditions: [x for x in numbers if x > 0]\n- Prefer over map() and filter() for readability\n\nError Handling:\n- Use try/except blocks for error handling\n- Catch specific exceptions, not generic Exception\n- Use finally for cleanup code\n- Use with statements for resource management\n\nFile Operations:\n- Use with open() for automatic file closing\n- Specify encoding for text files\n- Handle file not found exceptions",
      "metadata": {
        "language": "python",
        "topic": "fundamentals"
      }
    },
    {
      "content": "Python Advanced Concepts:\n\nObject-Oriented Programming:\n- Define classes with class keyword\n- Use __init__ for constructor\n- Use self to refer to instance\n- Use @classmethod and @staticmethod decorators\n- Use inheritance for code reuse\n- Use encapsulation with private attributes (_variable)\n\nDecorators:\n- Functions that modify other functions\n- Use @decorator syntax\n- Common decorators: @property, @staticmethod, @classmethod\n- Create custom decorators for logging, timing, etc.\n\nContext Managers:\n- Use with statements for resource management\n- Implement __enter__ and __exit__ methods\n- Use contextlib for simple context managers\n\nGenerators:\n- Use yield instead of return for memory efficiency\n- Create iterators without storing all data in memory\n- Use generator expressions for simple cases\n\nLambda Functions:\n- Use for simple, one-line functions\n- Common in sorting: sorted(items, key=lambda x: x[1])\n- Don't overuse - prefer regular functions for complexity\n\nModules and Packages:\n- Use import for modules\n- Use from module import item for specific imports\n- Use __init__.py to make directories packages\n- Use relative imports within packages",
      "metadata": {
        "language": "python",
        "topic": "advanced"
      }
    },
    {
      "content": "Python Common Patterns and Idioms:\n\nDictionary Operations:\n- Use .get() with default values: dict.get('key', 'default')\n- Use .setdefault() for conditional assignment\n- Use dict comprehension: {k: v for k, v in items}\n- Use .items() for key-value iteration\n\nList Operations:\n- Use .append() to add items\n- Use .extend() to add multiple items\n- Use .insert() to add at specific position\n- Use .remove() and .pop() to remove items\n- Use slicing for sublists: list[start:end:step]\n\nString Operations:\n- Use f-strings for formatting: f\"Hello {name}\"\n- Use .join() to concatenate strings efficiently\n- Use .split() to break strings into lists\n- Use .strip() to remove whitespace\n- Use .replace() for string substitution\n\nEnumerate and Zip:\n- Use enumerate() for index-value pairs\n- Use zip() to combine multiple iterables\n- Use zip_longest() for different length iterables\n\nAny and All:\n- Use any() to check if any item is True\n- Use all() to check if all items are True\n- Combine with generator expressions for efficiency\n\nCollections Module:\n- Use Counter for counting occurrences\n- Use defaultdict for default values\n- Use namedtuple for simple data structures\n- Use deque for efficient queue operations",
      "metadata": {
        "language": "python",
        "topic": "patterns"
      }
    },
    {
      "content": "Python Common Errors and Solutions:\n\nIndentationError:\n- Cause: Incorrect indentation (mixing tabs and spaces)\n- Solution: Use consistent indentation (4 spaces recommended)\n- Prevention: Configure editor to use spaces, not tabs\n\nNameError: name 'variable' is not defined:\n- Cause: Using variable before defining it\n- Solution: Define variable before using it\n- Prevention: Check variable scope and spelling\n\nTypeError: unsupported operand type(s):\n- Cause: Using wrong data types together\n- Solution: Convert types explicitly: str(), int(), float()\n- Prevention: Check data types before operations\n\nIndexError: list index out of range:\n- Cause: Accessing index that doesn't exist\n- Solution: Check list length before accessing\n- Prevention: Use len() or try/except\n\nKeyError: 'key':\n- Cause: Accessing dictionary key that doesn't exist\n- Solution: Use .get() method with default value\n- Prevention: Check if key exists with 'in' operator\n\nAttributeError: object has no attribute:\n- Cause: Calling method that doesn't exist\n- Solution: Check object type and available methods\n- Prevention: Use hasattr() or dir() to check attributes\n\nImportError: No module named:\n- Cause: Module not installed or wrong path\n- Solution: Install module with pip or check import path\n- Prevention: Use virtual environments\n\nZeroDivisionError: division by zero:\n- Cause: Dividing by zero\n- Solution: Check denominator before division\n- Prevention: Use conditional checks\n\nFileNotFoundError: No such file or directory:\n- Cause: File doesn't exist at specified path\n- Solution: Check file path and existence\n- Prevention: Use os.path.exists() to check\n\nValueError: invalid literal for int():\n- Cause: Converting non-numeric string to int\n- Solution: Validate input before conversion\n- Prevention: Use try/except or input validation",
      "metadata": {
        "language": "python",
        "topic": "error_handling"
      }
    },
    {
      "content": "JavaScript Fundamentals and Best Practices:\n\nVariables and Data Types:\n- Use const for values that won't change\n- Use let for values that will change\n- Avoid var (function-scoped, can cause issues)\n- Data types: number, string, boolean, object, array, null, undefined\n- Use camelCase for variable and function names\n- Use UPPER_CASE for constants\n\nControl Structures:\n- Use if/else if/else for conditional logic\n- Use for, while, do-while loops\n- Use break and continue for loop control\n- Use switch statements for multiple conditions\n\nFunctions:\n- Use function declarations or arrow functions\n- Arrow functions: const func = () => {}\n- Use default parameters: function func(param = 'default') {}\n- Use rest parameters: function func(...args) {}\n- Use return statements explicitly\n\nArrays:\n- Use array literals: [1, 2, 3]\n- Use .push() to add items\n- Use .pop() to remove last item\n- Use .shift() and .unshift() for front operations\n- Use .splice() for insertions and deletions\n\nArray Methods:\n- .map() for transformations\n- .filter() for filtering\n- .reduce() for aggregations\n- .find() and .findIndex() for searching\n- .some() and .every() for testing\n- .forEach() for iteration\n\nObjects:\n- Use object literals: {key: 'value'}\n- Use dot notation: obj.property\n- Use bracket notation: obj['property']\n- Use Object.keys(), Object.values(), Object.entries()\n- Use destructuring: const {prop} = obj\n\nTemplate Literals:\n- Use backticks for template literals\n- Use ${expression} for interpolation\n- Use multi-line strings without concatenation\n\nError Handling:\n- Use try/catch blocks\n- Use throw to create custom errors\n- Use finally for cleanup code\n- Create custom error classes",
      "metadata": {
        "language": "javascript",
        "topic": "fundamentals"
      }
    },
    {
      "content": "JavaScript Advanced Concepts:\n\nClosures:\n- Functions that remember their lexical scope\n- Used for data privacy and state management\n- Common in callbacks and event handlers\n- Be careful with loops and closures\n\nPromises:\n- Handle asynchronous operations\n- Use .then() for success handlers\n- Use .catch() for error handlers\n- Use .finally() for cleanup\n- Chain promises for sequential operations\n\nAsync/Await:\n- Syntactic sugar for promises\n- Use async function declaration\n- Use await to wait for promises\n- Handle errors with try/catch\n- More readable than promise chains\n\nClasses:\n- Use class keyword for object-oriented programming\n- Use constructor() for initialization\n- Use extends for inheritance\n- Use super() to call parent constructor\n- Use static methods for class-level operations\n\nModules:\n- Use import/export for modular code\n- Use default exports for main exports\n- Use named exports for multiple exports\n- Use * as namespace for all exports\n\nDestructuring:\n- Array destructuring: const [a, b] = array\n- Object destructuring: const {prop} = object\n- Use default values: const {prop = 'default'} = object\n- Use rest operator: const [first, ...rest] = array\n\nSpread Operator:\n- Copy arrays: [...array]\n- Copy objects: {...object}\n- Combine arrays: [...array1, ...array2]\n- Pass arguments: func(...args)\n\nArrow Functions:\n- Shorter syntax: const func = () => {}\n- Implicit return for single expressions\n- Lexical this binding\n- Don't use for object methods (loses this)",
      "metadata": {
        "language": "javascript",
        "topic": "advanced"
      }
    },
    {
      "content": "JavaScript Common Patterns and Idioms:\n\nObject Patterns:\n- Factory functions for object creation\n- Module pattern for encapsulation\n- Revealing module pattern\n- Singleton pattern for single instances\n\nArray Patterns:\n- Use .map() for transformations\n- Use .filter() for filtering\n- Use .reduce() for aggregations\n- Use .flatMap() for map and flatten\n- Use .slice() for copying arrays\n\nString Patterns:\n- Use .includes() for substring checking\n- Use .startsWith() and .endsWith()\n- Use .replace() with regex for complex replacements\n- Use .split() and .join() for transformations\n\nFunction Patterns:\n- Higher-order functions (functions that return functions)\n- Partial application and currying\n- Function composition\n- Memoization for performance\n\nEvent Handling:\n- Use addEventListener for event binding\n- Use removeEventListener to prevent memory leaks\n- Use event delegation for dynamic content\n- Use preventDefault() and stopPropagation()\n\nDOM Manipulation:\n- Use querySelector and querySelectorAll\n- Use createElement and appendChild\n- Use classList for class management\n- Use dataset for custom data attributes\n\nLocal Storage:\n- Use localStorage for persistent data\n- Use sessionStorage for session data\n- Serialize objects with JSON.stringify()\n- Deserialize with JSON.parse()\n\nFetch API:\n- Use fetch() for HTTP requests\n- Handle responses with .then() or async/await\n- Check response.ok for HTTP errors\n- Use .json() to parse JSON responses",
      "metadata": {
        "language": "javascript",
        "topic": "patterns"
      }
    },
    {
      "content": "JavaScript Common Errors and Solutions:\n\nReferenceError: variable is not defined:\n- Cause: Using variable before declaration or wrong scope\n- Solution: Declare variable with let/const before use\n- Prevention: Use strict mode and check variable scope\n\nTypeError: Cannot read property of undefined:\n- Cause: Accessing property of undefined/null object\n- Solution: Check if object exists before accessing\n- Prevention: Use optional chaining (?.) or null checks\n\nSyntaxError: Unexpected token:\n- Cause: Invalid JavaScript syntax\n- Solution: Check for missing brackets, semicolons, quotes\n- Prevention: Use linter and proper formatting\n\nRangeError: Maximum call stack size exceeded:\n- Cause: Infinite recursion or deep function calls\n- Solution: Add base case or limit recursion depth\n- Prevention: Check recursive function termination\n\nTypeError: Cannot read property 'length' of undefined:\n- Cause: Calling array methods on undefined\n- Solution: Check if array exists before using methods\n- Prevention: Use Array.isArray() or default values\n\nTypeError: .map is not a function:\n- Cause: Calling array method on non-array\n- Solution: Ensure variable is an array before calling\n- Prevention: Use Array.isArray() or convert to array\n\nReferenceError: Cannot access before initialization:\n- Cause: Using let/const before declaration (temporal dead zone)\n- Solution: Move declaration before usage\n- Prevention: Declare variables at top of scope\n\nTypeError: Assignment to constant variable:\n- Cause: Trying to reassign const variable\n- Solution: Use let instead of const for mutable values\n- Prevention: Use const only for values that won't change\n\nSyntaxError: Unexpected end of input:\n- Cause: Missing closing brackets, braces, or quotes\n- Solution: Check for matching pairs\n- Prevention: Use editor with bracket matching\n\nTypeError: Failed to fetch:\n- Cause: Network error or CORS issue\n- Solution: Check network connection and CORS settings\n- Prevention: Handle fetch errors with try/catch",
      "metadata": {
        "language": "javascript",
        "topic": "error_handling"
      }
    },
    {
      "content": "Performance and Optimization Best Practices:\n\nPython Performance:\n- Use list comprehensions over loops when possible\n- Use sets for membership testing (faster than lists)\n- Use generators for large datasets\n- Profile code with cProfile or line_profiler\n- Use __slots__ for memory optimization in classes\n- Avoid global variables in loops\n\nJavaScript Performance:\n- Use for...of instead of for...in for arrays\n- Use Set and Map for better performance\n- Avoid DOM queries in loops\n- Use requestAnimationFrame for animations\n- Debounce event handlers for frequent events\n- Use Web Workers for CPU-intensive tasks\n\nMemory Management:\n- Close file handles and database connections\n- Remove event listeners to prevent memory leaks\n- Use weak references for caching\n- Avoid circular references\n- Use object pooling for frequently created objects\n\nAlgorithm Optimization:\n- Choose appropriate data structures\n- Use caching for expensive operations\n- Optimize loops and nested operations\n- Use built-in functions when available\n- Consider time and space complexity\n\nCode Quality:\n- Write readable, maintainable code\n- Use meaningful variable and function names\n- Add comments for complex logic\n- Follow style guides (PEP 8, ESLint)\n- Write unit tests for critical functions\n- Use type hints and documentation",
      "metadata": {
        "language": "general",
        "topic": "performance"
      }
    },
    {
      "content": "Debugging and Testing Strategies:\n\nPython Debugging:\n- Use print() statements for simple debugging\n- Use pdb or ipdb for interactive debugging\n- Use logging module for structured logging\n- Use assert statements for quick checks\n- Use try/except for error handling\n\nJavaScript Debugging:\n- Use console.log() for simple debugging\n- Use browser developer tools\n- Use debugger statement for breakpoints\n- Use console.table() for tabular data\n- Use console.trace() for call stack\n\nTesting Approaches:\n- Write unit tests for individual functions\n- Use test-driven development (TDD)\n- Test edge cases and error conditions\n- Use mocking for external dependencies\n- Maintain good test coverage\n\nCommon Debugging Techniques:\n- Add logging at key points\n- Use step-through debugging\n- Check variable values and types\n- Verify function inputs and outputs\n- Test with minimal examples\n- Use version control to track changes\n\nError Prevention:\n- Validate inputs and outputs\n- Use defensive programming\n- Handle edge cases explicitly\n- Use type checking and validation\n- Write clear error messages\n- Document assumptions and requirements",
      "metadata": {
        "language": "general",
        "topic": "debugging"
      }
    },
    {
      "content": "Common Code Patterns and Templates:\n\nPython Templates:\n- Basic function template with docstring\n- Class template with constructor\n- Context manager template\n- Decorator template\n- Generator function template\n\nJavaScript Templates:\n- Arrow function template\n- Class template with methods\n- Promise template with error handling\n- Async function template\n- Event listener template\n\nData Processing Patterns:\n- Map-reduce operations\n- Filter and transform data\n- Group and aggregate data\n- Sort and search algorithms\n- Data validation patterns\n\nFile Handling Patterns:\n- Read and write files safely\n- Process CSV and JSON data\n- Handle different file formats\n- Error handling for file operations\n- Batch processing of files\n\nWeb Development Patterns:\n- API request handling\n- Form validation\n- Data serialization\n- Error handling for web requests\n- State management patterns\n\nAlgorithm Patterns:\n- Recursive functions\n- Iterative solutions\n- Divide and conquer\n- Dynamic programming\n- Greedy algorithms",
      "metadata": {
        "language": "general",
        "topic": "templates"
      }
    }
  ]
} 